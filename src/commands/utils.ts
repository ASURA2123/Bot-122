import { Command } from "../types";
import config from "../config";
import moment from "moment";
import { logger } from "../utils/logger";
import axios from "axios";

// L∆∞u tr·ªØ t∆∞∆°ng t√°c c·ªßa th√†nh vi√™n
const userInteractions = new Map<string, number>();

export const addFriend: Command = {
  name: "addfriend",
  description: "K·∫øt b·∫°n v·ªõi ng∆∞·ªùi d√πng qua ID Facebook",
  usage: `${config.prefix}addfriend <ID>`,
  execute: async (api, event) => {
    try {
      const userID = event.body.slice(config.prefix.length + 9).trim();
      if (!userID) {
        const error = new Error("Missing user ID");
        error.name = "InvalidArgumentError";
        throw error;
      }

      // Ki·ªÉm tra ID c√≥ h·ª£p l·ªá kh√¥ng
      const userInfo = await api.getUserInfo(userID);
      if (!userInfo[userID]) {
        const error = new Error(`User ID ${userID} not found`);
        error.name = "UserNotFoundError";
        throw error;
      }

      // G·ª≠i l·ªùi m·ªùi k·∫øt b·∫°n
      await api.addUserToGroup(userID, event.threadID);
      await api.sendMessage(
        `‚úÖ ƒê√£ g·ª≠i l·ªùi m·ªùi k·∫øt b·∫°n t·ªõi ${userInfo[userID].name} (${userID})`,
        event.threadID
      );
    } catch (error) {
      const err = error instanceof Error ? error : new Error(String(error));
      err.name = err.name || "AddFriendError";
      logger.error("L·ªói khi k·∫øt b·∫°n", err);
      await api.sendMessage("‚ùå Kh√¥ng th·ªÉ g·ª≠i l·ªùi m·ªùi k·∫øt b·∫°n. Vui l√≤ng th·ª≠ l·∫°i sau.", event.threadID);
    }
  }
};

export const setlove: Command = {
  name: "setlove",
  description: "ƒê·∫∑t bi·ªát danh cho th√†nh vi√™n trong nh√≥m",
  usage: `${config.prefix}setlove <@tag> <bi·ªát danh>`,
  execute: async (api, event) => {
    try {
      const mentions = event.mentions;
      if (!mentions || Object.keys(mentions).length === 0) {
        const error = new Error("No user mentioned");
        error.name = "InvalidArgumentError";
        throw error;
      }

      const nickname = event.body.split(" ").slice(2).join(" ");
      if (!nickname) {
        const error = new Error("Missing nickname");
        error.name = "InvalidArgumentError";
        throw error;
      }

      const threadInfo = await api.getThreadInfo(event.threadID);
      const botID = api.getCurrentUserID();
      const isAdmin = threadInfo.adminIDs?.includes(botID);

      if (!isAdmin) {
        const error = new Error("Bot needs admin permission");
        error.name = "PermissionError";
        throw error;
      }

      // ƒê·ªïi bi·ªát danh cho t·ª´ng ng∆∞·ªùi ƒë∆∞·ª£c tag
      for (const [userID, userName] of Object.entries(mentions)) {
        try {
          // TODO: Implement setNickname when available in API types
          await api.sendMessage(`‚úÖ ƒê√£ ƒë·ªïi bi·ªát danh c·ªßa ${userName} th√†nh: ${nickname}`, event.threadID);
        } catch (error) {
          const err = error instanceof Error ? error : new Error(String(error));
          err.name = "SetNicknameError";
          logger.error(`L·ªói khi ƒë·ªïi bi·ªát danh cho ${userName}`, err);
        }
      }
    } catch (error) {
      const err = error instanceof Error ? error : new Error(String(error));
      err.name = err.name || "SetLoveError";
      logger.error("L·ªói l·ªánh setlove", err);
      await api.sendMessage("‚ùå Kh√¥ng th·ªÉ ƒë·ªïi bi·ªát danh. Vui l√≤ng th·ª≠ l·∫°i sau.", event.threadID);
    }
  }
};

export const uptime: Command = {
  name: "uptime",
  description: "Xem th·ªùi gian bot ƒë√£ online",
  usage: `${config.prefix}uptime`,
  execute: async (api, event) => {
    try {
      const startTime = process.uptime();
      const days = Math.floor(startTime / 86400);
      const hours = Math.floor((startTime % 86400) / 3600);
      const minutes = Math.floor((startTime % 3600) / 60);
      const seconds = Math.floor(startTime % 60);

      const uptimeMessage = `‚è∞ Bot ƒë√£ ho·∫°t ƒë·ªông ƒë∆∞·ª£c:\n` +
        `üìÖ ${days} ng√†y\n` +
        `üïê ${hours} gi·ªù\n` +
        `‚è± ${minutes} ph√∫t\n` +
        `‚è≤ ${seconds} gi√¢y`;

      await api.sendMessage(uptimeMessage, event.threadID);
    } catch (error) {
      const err = error instanceof Error ? error : new Error(String(error));
      err.name = err.name || "UptimeError";
      logger.error("L·ªói l·ªánh uptime", err);
      await api.sendMessage("‚ùå Kh√¥ng th·ªÉ xem th·ªùi gian ho·∫°t ƒë·ªông. Vui l√≤ng th·ª≠ l·∫°i sau.", event.threadID);
    }
  }
};

export const rankup: Command = {
  name: "rankup",
  description: "Xem th·ª© h·∫°ng t∆∞∆°ng t√°c trong nh√≥m",
  usage: `${config.prefix}rankup [@tag]`,
  execute: async (api, event) => {
    try {
      const userID = event.mentions ? Object.keys(event.mentions)[0] : event.senderID;
      const interactions = userInteractions.get(userID) || 0;
      const rank = Array.from(userInteractions.entries())
        .sort(([, a], [, b]) => b - a)
        .findIndex(([id]) => id === userID) + 1;

      const userInfo = await api.getUserInfo(userID);
      const userName = userInfo[userID].name;

      const rankMessage = `üë§ Th√†nh vi√™n: ${userName}\n` +
        `üí¨ S·ªë tin nh·∫Øn: ${interactions}\n` +
        `üèÜ Th·ª© h·∫°ng: #${rank}`;

      await api.sendMessage(rankMessage, event.threadID);
    } catch (error) {
      const err = error instanceof Error ? error : new Error(String(error));
      err.name = err.name || "RankupError";
      logger.error("L·ªói l·ªánh rankup", err);
      await api.sendMessage("‚ùå Kh√¥ng th·ªÉ xem th·ª© h·∫°ng. Vui l√≤ng th·ª≠ l·∫°i sau.", event.threadID);
    }
  }
};

export const weather: Command = {
  name: "weather",
  description: "Xem th√¥ng tin th·ªùi ti·∫øt t·∫°i khu v·ª±c",
  usage: `${config.prefix}weather <t√™n th√†nh ph·ªë>`,
  execute: async (api, event) => {
    try {
      const city = event.body.slice(config.prefix.length + 8).trim();
      if (!city) {
        const error = new Error("Missing city name");
        error.name = "InvalidArgumentError";
        throw error;
      }

      const response = await axios.get(
        `http://api.openweathermap.org/data/2.5/weather?q=${encodeURIComponent(city)}&appid=${process.env.WEATHER_API_KEY}&units=metric&lang=vi`
      );

      const data = response.data;
      const weather = `üå§ Th·ªùi ti·∫øt t·∫°i ${data.name}:\n\n` +
        `üå° Nhi·ªát ƒë·ªô: ${Math.round(data.main.temp)}¬∞C\n` +
        `üíß ƒê·ªô ·∫©m: ${data.main.humidity}%\n` +
        `üå™ Gi√≥: ${data.wind.speed}m/s\n` +
        `‚òÅ M√¢y: ${data.clouds.all}%\n` +
        `üìù M√¥ t·∫£: ${data.weather[0].description}\n` +
        `‚è∞ C·∫≠p nh·∫≠t: ${moment.unix(data.dt).format('LLL')}`;

      await api.sendMessage(weather, event.threadID);
    } catch (error) {
      const err = error instanceof Error ? error : new Error(String(error));
      err.name = err.name || "WeatherError";
      logger.error("L·ªói l·ªánh weather", err);
      await api.sendMessage("‚ùå Kh√¥ng th·ªÉ l·∫•y th√¥ng tin th·ªùi ti·∫øt. Vui l√≤ng th·ª≠ l·∫°i sau.", event.threadID);
    }
  }
};

export const wiki: Command = {
  name: "wiki",
  description: "T√¨m th√¥ng tin t·ª´ Wikipedia",
  usage: `${config.prefix}wiki <t·ª´ kho√°>`,
  execute: async (api, event) => {
    try {
      const query = event.body.slice(config.prefix.length + 5).trim();
      if (!query) {
        const error = new Error("Missing search query");
        error.name = "InvalidArgumentError";
        throw error;
      }

      // Wikipedia API endpoint
      const response = await axios.get(
        `https://vi.wikipedia.org/api/rest_v1/page/summary/${encodeURIComponent(query)}`,
        {
          headers: {
            'User-Agent': 'MessengerBot/1.0'
          }
        }
      );

      if (response.data.type === 'disambiguation') {
        await api.sendMessage(
          "‚ùì C√≥ nhi·ªÅu k·∫øt qu·∫£ ph√π h·ª£p. Vui l√≤ng th·ª≠ t√¨m ki·∫øm c·ª• th·ªÉ h∆°n.",
          event.threadID
        );
        return;
      }

      const title = response.data.title;
      const extract = response.data.extract;
      const url = response.data.content_urls?.desktop?.page;

      const message = `üìö ${title}\n\n` +
        `${extract}\n\n` +
        (url ? `üîó ƒê·ªçc th√™m: ${url}` : '');

      await api.sendMessage(message, event.threadID);
    } catch (error) {
      const err = error instanceof Error ? error : new Error(String(error));
      err.name = err.name || "WikiError";
      logger.error("L·ªói l·ªánh wiki", err);
      await api.sendMessage("‚ùå Kh√¥ng th·ªÉ t√¨m th√¥ng tin. Vui l√≤ng th·ª≠ l·∫°i sau.", event.threadID);
    }
  }
};

export const wake: Command = {
  name: "wake",
  description: "T√≠nh th·ªùi gian th·ª©c d·∫≠y ho√†n h·∫£o",
  usage: `${config.prefix}wake [gi·ªù ƒëi ng·ªß]`,
  execute: async (api, event) => {
    try {
      let bedtime = moment();
      const timeArg = event.body.split(" ")[1];

      if (timeArg) {
        // N·∫øu ng∆∞·ªùi d√πng nh·∫≠p gi·ªù ƒëi ng·ªß
        bedtime = moment(timeArg, "HH:mm");
        if (!bedtime.isValid()) {
          const error = new Error("Invalid time format. Please use HH:mm (e.g., 23:00)");
          error.name = "InvalidArgumentError";
          throw error;
        }
      }

      // T√≠nh c√°c chu k·ª≥ ng·ªß (m·ªói chu k·ª≥ 90 ph√∫t)
      const cycles = [5, 6, 7]; // 5-7 chu k·ª≥ l√† t·ªët nh·∫•t
      let message = "‚è∞ Th·ªùi gian th·ª©c d·∫≠y t·ªët nh·∫•t:\n\n";

      cycles.forEach(cycle => {
        const wakeTime = moment(bedtime).add(cycle * 90, "minutes");
        message += `${cycle} chu k·ª≥ (${cycle * 1.5}h): ${wakeTime.format("HH:mm")}\n`;
      });

      message += "\nüí° M·ªói chu k·ª≥ ng·ªß k√©o d√†i 90 ph√∫t. B·∫°n n√™n ho√†n th√†nh 5-7 chu k·ª≥ ƒë·ªÉ c√≥ gi·∫•c ng·ªß khoa h·ªçc nh·∫•t.";
      await api.sendMessage(message, event.threadID);
    } catch (error) {
      const err = error instanceof Error ? error : new Error(String(error));
      err.name = err.name || "WakeError";
      logger.error("L·ªói l·ªánh wake", err);
      await api.sendMessage("‚ùå Kh√¥ng th·ªÉ t√≠nh th·ªùi gian th·ª©c d·∫≠y. Vui l√≤ng th·ª≠ l·∫°i sau.", event.threadID);
    }
  }
};

export const checkin: Command = {
  name: "checkin",
  description: "Xem th·ªëng k√™ t∆∞∆°ng t√°c c·ªßa nh√≥m",
  usage: `${config.prefix}checkin`,
  execute: async (api, event) => {
    try {
      // L·∫•y danh s√°ch th√†nh vi√™n c√≥ t∆∞∆°ng t√°c
      const sortedUsers = Array.from(userInteractions.entries())
        .sort(([, a], [, b]) => b - a);

      if (sortedUsers.length === 0) {
        await api.sendMessage("üìä Ch∆∞a c√≥ d·ªØ li·ªáu t∆∞∆°ng t√°c n√†o.", event.threadID);
        return;
      }

      // L·∫•y th√¥ng tin top 10 th√†nh vi√™n
      const top10 = await Promise.all(
        sortedUsers.slice(0, 10).map(async ([id, count], index) => {
          const userInfo = await api.getUserInfo(id);
          return `${index + 1}. ${userInfo[id].name}: ${count} tin nh·∫Øn`;
        })
      );

      const totalMessages = sortedUsers.reduce((sum, [, count]) => sum + count, 0);
      const totalUsers = sortedUsers.length;

      const stats = `üìä Th·ªëng k√™ t∆∞∆°ng t√°c nh√≥m:\n\n` +
        `üë• T·ªïng th√†nh vi√™n t∆∞∆°ng t√°c: ${totalUsers}\n` +
        `üí¨ T·ªïng tin nh·∫Øn: ${totalMessages}\n\n` +
        `üèÜ Top 10 th√†nh vi√™n t√≠ch c·ª±c:\n${top10.join('\n')}`;

      await api.sendMessage(stats, event.threadID);
    } catch (error) {
      const err = error instanceof Error ? error : new Error(String(error));
      err.name = err.name || "CheckinError";
      logger.error("L·ªói l·ªánh checkin", err);
      await api.sendMessage("‚ùå Kh√¥ng th·ªÉ xem th·ªëng k√™. Vui l√≤ng th·ª≠ l·∫°i sau.", event.threadID);
    }
  }
};